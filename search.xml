<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spdlog使用相关</title>
      <link href="2024/01/30/spdlog%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/"/>
      <url>2024/01/30/spdlog%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鉴于工作需求，日志记录工具是必不可少的存在。<br>现对 spdlog 在c++项目的使用方法进行探究。  </p><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><pre><code>https://github.com/gabime/spdlog#compiled-version-recommended---much-faster-compile-times</code></pre><p>官方说明文档地址   </p><pre><code>https://github.com/gabime/spdlog/wiki</code></pre><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>将项目源码中的 inlcude 中的 spdlog 文件夹添加到自己的项目中即可使用。<br>该项目通过 logger 作为对象进行调用，logger 接受用户的日志信息，对应日志的输入端，然后传递给 sink，sink对应日志的输出端。<br>所以通过建立多个 sink 对应一个 logger 就可以实现同日志输入但是输出多个不同等级要求的日志文件。  </p><h1 id="完整Demo"><a href="#完整Demo" class="headerlink" title="完整Demo"></a>完整Demo</h1><p>main文件初始化日志代码：   </p><pre><code>#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;#include &lt;QSettings&gt;#include &lt;QDir&gt;#include &lt;QDebug&gt;#include &quot;log4z/log4z.h&quot;#include &quot;spdlog/spdlog.h&quot;#include &quot;spdlog/sinks/daily_file_sink.h&quot;#include &quot;spdlog/sinks/stdout_color_sinks.h&quot; // or &quot;../stdout_sinks.h&quot; if no colors neededvoid initSPDLOG()&#123;    auto console_sink = std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;();    console_sink-&gt;set_level(spdlog::level::warn);    auto file_sink_trace = std::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(&quot;logs/Trace/Trace.log&quot;, 23, 59, false);    file_sink_trace-&gt;set_level(spdlog::level::trace);    auto file_sink_debug = std::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(&quot;logs/debug/debug.log&quot;, 23, 59, false, 0);    file_sink_debug-&gt;set_level(spdlog::level::debug);    auto file_sink_info = std::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(&quot;logs/Info/Info.log&quot;, 23, 59, false, 0);    file_sink_info-&gt;set_level(spdlog::level::info);    auto file_sink_warn = std::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(&quot;logs/warn/warn.log&quot;, 23, 59, false, 0);    file_sink_warn-&gt;set_level(spdlog::level::warn);    auto file_sink_err = std::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(&quot;logs/err/err.log&quot;, 23, 59, false, 0);    file_sink_err-&gt;set_level(spdlog::level::err);    auto file_sink_critical = std::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(&quot;logs/critical/critical.log&quot;, 23, 59, false, 0);    file_sink_critical-&gt;set_level(spdlog::level::critical);    // 组合sink列表    spdlog::sinks_init_list sink_list = &#123; console_sink, file_sink_trace, file_sink_debug, file_sink_info, file_sink_warn,                                        file_sink_err, file_sink_critical&#125;;    // 将sink列表设置到全局    spdlog::set_default_logger(std::make_shared&lt;spdlog::logger&gt;(&quot;multi_sink&quot;, sink_list));    // 设置日志内容输出格式    spdlog::set_pattern(&quot;[%Y-%m-%d %H:%M:%S.%e] %^[%l]%$ %v&quot;);    // spdlog 默认level为 INfo 需要手动改 trace    spdlog::set_level(spdlog::level::trace);    // 设置刷新，刷新本地文件，以便随时查看本地日志文件    spdlog::flush_every(std::chrono::seconds(5));&#125;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    AllocConsole();    freopen(&quot;CONOUT$&quot;, &quot;a+&quot;, stdout);    // psdLog    initSPDLOG();    MainWindow w;    w.show();    return a.exec();&#125;</code></pre><p>全局使用方法：   </p><pre><code>    int myMesg = 1;    QString testMesg = &quot;hello word&quot;;    spdlog::trace(&quot;trace message &#123;&#125; &#123;&#125;&quot;, myMesg, testMesg.toStdString().c_str());    spdlog::debug(&quot;debug message&quot;);    spdlog::info(&quot;info message&quot;);    spdlog::warn(&quot;waring message&quot;);    spdlog::error(&quot;error message&quot;);    spdlog::critical(&quot;critical message&quot;);</code></pre><p>如需要添加新的输出 sink，如 qt 控件。  </p><pre><code>    auto qt_sink_trace = std::make_shared&lt;spdlog::sinks::qt_sink_mt&gt;(ui-&gt;plainTextEdit, &quot;appendPlainText&quot;);    qt_sink_trace-&gt;set_level(spdlog::level::trace);    spdlog::get(&quot;multi_sink&quot;)-&gt;sinks().push_back(qt_sink_trace);</code></pre><p>记下来对代码内容进行说明</p><h2 id="新建-sink"><a href="#新建-sink" class="headerlink" title="新建 sink"></a>新建 sink</h2><pre><code>#include &quot;spdlog/sinks/daily_file_sink.h&quot;#include &quot;spdlog/sinks/stdout_color_sinks.h&quot; // or &quot;../stdout_sinks.h&quot; if no colors needed    auto console_sink = std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;();    console_sink-&gt;set_level(spdlog::level::warn);    auto file_sink_trace = std::make_shared&lt;spdlog::sinks::daily_file_sink_mt&gt;(&quot;logs/Trace/Trace.log&quot;, 23, 59, false);    file_sink_trace-&gt;set_level(spdlog::level::trace);</code></pre><p>sink 作为日志的输出，有很多种。 常用如下，其余可参考说明文档。    </p><table><thead><tr><th>类名</th><th>特性</th></tr></thead><tbody><tr><td>rotating_file_sink</td><td>可根据设定的大小自动分开日志文件</td></tr><tr><td>daily_file_sink</td><td>可根据设定的日期自动分开日志文件</td></tr><tr><td>simple_file_sink</td><td>固定一个文件</td></tr><tr><td>stdout_color_sink</td><td>标准输出</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>代码中使用时需要添加对应 sink 头文件。</td><td></td></tr><tr><td>不同 sink 需要的构造参数不同，可参考对应构造函数。</td><td></td></tr><tr><td>其中 truncate 设定 false 表示如果存在同名日志，在其后继续记录，否则清空从头开始记录。</td><td></td></tr><tr><td>每一个 sink 构造时分为 mt 和 st，根据官方文档说明 mt 表示 multithrad，st 表示 singlethread。</td><td></td></tr><tr><td>为了线程安全只用 mt 就好，st 特殊需求可能会用到。</td><td></td></tr></tbody></table><h2 id="新建-logger"><a href="#新建-logger" class="headerlink" title="新建 logger"></a>新建 logger</h2><pre><code>    // 组合sink列表    spdlog::sinks_init_list sink_list = &#123; console_sink, file_sink_trace, file_sink_debug, file_sink_info, file_sink_warn,                                        file_sink_err, file_sink_critical&#125;;</code></pre><p>通过 sinks_init_list 将所有建立的 sink 放到一个列表里，变量名为 sink_list。   </p><pre><code>// 将sink列表设置到全局    spdlog::set_default_logger(std::make_shared&lt;spdlog::logger&gt;(&quot;multi_sink&quot;, sink_list));</code></pre><p>这段代码有两层意思，组合到了一起。<br>先通过 make_shared 建造了一个标准 logger，将 sink_list 作为构造参数传入，获得一个 logger，变量名为 multi_sink， 再通过 spdlog::set_dafult_logger 将刚刚创建的 multi_sink 设定为全局 logger。<br>这样在别的任意地方调用默认打印日志的方法就会调用 multi_sink 这个 logger。</p><pre><code>    // 设置日志内容输出格式    spdlog::set_pattern(&quot;[%Y-%m-%d %H:%M:%S.%e] %^[%l]%$ %v&quot;);</code></pre><p>设定全局的日志输出格式。<br>如果有不同 sink 不同格式的需求，可以直接给单个 sink 进行设置。<br>设置方法详见说明文档。  </p><pre><code>    // spdlog 默认level为 INfo 需要手动改 trace    spdlog::set_level(spdlog::level::trace);</code></pre><p>spdlog 默认全局 level 为 INFO，如果不设置的话 debug 和 trace 的信息将无法输出。  </p><pre><code>    // 设置刷新，刷新本地文件，以便随时查看本地日志文件    spdlog::flush_every(std::chrono::seconds(5));</code></pre><p>不设置这个的话调试窗口的日志也能正常输出，但是本地文件流只有在程序关闭的时候才会全部写入。<br>通过设定5s刷新，就能随时查看本地文件的日志了。  </p><h2 id="全局输出日志"><a href="#全局输出日志" class="headerlink" title="全局输出日志"></a>全局输出日志</h2><pre><code>    #include &quot;spdlog/spdlog.h&quot;    int myMesg = 1;    QString testMesg = &quot;hello word&quot;;    spdlog::trace(&quot;trace message &#123;&#125; &#123;&#125;&quot;, myMesg, testMesg.toStdString().c_str());    spdlog::debug(&quot;debug message&quot;);    spdlog::info(&quot;info message&quot;);    spdlog::warn(&quot;waring message&quot;);    spdlog::error(&quot;error message&quot;);    spdlog::critical(&quot;critical message&quot;);</code></pre><p>在需要打印日志的地方引入头文件，然后直接进行全局日志输出方法调用。<br>需要传参就通过 {} 类python的写法，很方便。  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> spdlog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>b站视频压制</title>
      <link href="2023/03/24/b%E7%AB%99%E8%A7%86%E9%A2%91%E5%8E%8B%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3/"/>
      <url>2023/03/24/b%E7%AB%99%E8%A7%86%E9%A2%91%E5%8E%8B%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是一篇关于如何获取b站最优画质的上传探索文章。<br>b站曾经还是小破站的时候，需要用渣浪的服务器来传视频，那时候为了获取极佳的画质，就有了留后黑来降低平均码率获得高画质的方法。<br>后来啊b富有了，有一段视频码率很夸张的时代，可以说基本不用考虑二压。<br>然后啊b又穷了，二压线又又又来了！  </p><h1 id="啊b二压门槛"><a href="#啊b二压门槛" class="headerlink" title="啊b二压门槛"></a>啊b二压门槛</h1><p>根据b站up 我真的没有天分丶 的 <a href="https://www.bilibili.com/video/BV1ne411G7qy/?vd_source=f30bfaa2341a62352679272ad1d09fb7">BV1ne411G7qy</a> 统计数据，现在啊b的二压线为：  </p><p>1080P高清：2600Kbps<br>1080P60帧：5200Kbps<br>4K超清：18500Kbps  </p><p>鉴于啊b现在没有2k分辨率档位，为了获取更高的码率上限，都可以将1080p和2k拉到4k分辨率来骗高码率。<br>这里还有高阶技巧就是用最短边分辨率骗假4k。<br>详见 其棱无也 的 <a href="https://www.bilibili.com/video/BV1q44y127rB/?spm_id_from=333.788.recommend_more_video.1&vd_source=f30bfaa2341a62352679272ad1d09fb7">BV1q44y127rB</a>，有详细介绍。  </p><h1 id="压制软件对比"><a href="#压制软件对比" class="headerlink" title="压制软件对比"></a>压制软件对比</h1><p>博主浅薄的字幕组生涯解除过几款视频压制软件，分别是 大众无脑之王——小丸工具箱，开始追求一定效率的——ShanaEncoder，追求无脑显卡压制的——消极压制，参数众多看的头大的——MediaCoder ，效率最高的开源命令行软件——FFMPEG。<br>其余没有提到的就不管了，顺便把那个说格式工厂的叉出去。</p><p>下为测试视频压制记录与对比：<br>原视频：<br>分辨率 2k<br>码率   50Mbps<br>时长   10min  </p><p>小丸工具箱压制：<br>参数设置：分辨率 4k，码率18Mbps，2-pass，耗时 1h10m<br>上传结果：<a href="https://www.bilibili.com/video/BV1YY4y1Q7YH/?spm_id_from=333.880.my_history.page.click&vd_source=f30bfaa2341a62352679272ad1d09fb7">BV1YY4y1Q7YH</a></p><p>Shana压制：  </p><p>消极压制：<br>耗时：16:30 ~ 16:36，5~6分钟  </p><p>FFMPEG：  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 视频压制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QByteArray 的使用方法与技巧</title>
      <link href="2023/03/24/QByteArray%E7%9B%B8%E5%85%B3/"/>
      <url>2023/03/24/QByteArray%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>最近做了个芯片烧录的上位机，因为功能设计到串口连续数据读取打包解析等内容，需要用到 QByteArray，且存着原始二进制数据。关于 QByteArray 的详细介绍，有空可以阅览一下 Qt 的 help，这里记录下常用的相关操作，方便使用查阅用法。</p><h2 id="访问与赋值"><a href="#访问与赋值" class="headerlink" title="访问与赋值"></a>访问与赋值</h2><p>访问数据有四种方式， [] at() data[] constData[]，其中 [] 和 at 为可读可写，at 和 constData[] 为只读，因此访问效率最高。</p><h2 id="在末尾追加字符数据"><a href="#在末尾追加字符数据" class="headerlink" title="在末尾追加字符数据"></a>在末尾追加字符数据</h2><pre class="language-none"><code class="language-none">QByteArray a(&quot;free&quot;);QByteArray b(&quot;dom&quot;);a.append(b);</code></pre><p>还有 a+=b，听导师说这样会有拼接遗漏数据的可能？<br>还有 memcpy 拷贝的方法，虽然我没试成功过。  </p><h2 id="查找某个字符的位置"><a href="#查找某个字符的位置" class="headerlink" title="查找某个字符的位置"></a>查找某个字符的位置</h2><p>indexOf，返回对应数字的第一个位置。  </p><pre class="language-none"><code class="language-none">QByteArray a(&quot;abcd&quot;);int c &#x3D; a.indexOf(&#39;b&#39;);</code></pre><h2 id="从左向右截取字符串"><a href="#从左向右截取字符串" class="headerlink" title="从左向右截取字符串"></a>从左向右截取字符串</h2><pre class="language-none"><code class="language-none">QByteArray a(&quot;pineapple&quot;);QByteArray b &#x3D; a.left(4);b &#x3D; &quot;pine&quot;;</code></pre><h2 id="从右向左截取字符串"><a href="#从右向左截取字符串" class="headerlink" title="从右向左截取字符串"></a>从右向左截取字符串</h2><pre class="language-none"><code class="language-none">QByteArray a(&quot;pineapple&quot;);QByteArray b &#x3D; a.right(5);b &#x3D; &quot;apple&quot;;</code></pre><h2 id="截取部分字符串"><a href="#截取部分字符串" class="headerlink" title="截取部分字符串"></a>截取部分字符串</h2><pre class="language-none"><code class="language-none">QByteArray a(&quot;hello world&quot;);QByteArray b &#x3D; a.mid(6,3);  &#x2F;&#x2F;第一个参数代表从哪里开始，0对应h，5对应空格，第二个参数代表开始后多少长度b &#x3D; &quot;wor&quot;;QByteArray c &#x3D; a.mid(6);    &#x2F;&#x2F;一个参数就只代表从哪里开始，截取剩下所有内容。c &#x3D; &quot;world&quot;;</code></pre><h2 id="删除某段字符"><a href="#删除某段字符" class="headerlink" title="删除某段字符"></a>删除某段字符</h2><pre class="language-none"><code class="language-none">QByteArray a(&quot;hello world);a.remove(6,3);a &#x3D; &quot;hello ld&quot;;</code></pre><p><text class="color:red;"> 这个讲道理和截取左右字符串是不是互补关系呢？如果是的话效率是一样的吗？有待观察验证。</text></p><h2 id="指定位置插入字符串"><a href="#指定位置插入字符串" class="headerlink" title="指定位置插入字符串"></a>指定位置插入字符串</h2><pre class="language-none"><code class="language-none">QByteArray a(&quot;helloworld&quot;);a.insert(5,QByteArray(&quot; &quot;));a &#x3D; &quot;hello world&quot;;</code></pre><h2 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h2><pre class="language-none"><code class="language-none">QByteArray a(&quot;GoodBye world&quot;);QByteArray b(&quot;hello&quot;);a.replace(0, 7, b); &#x2F;&#x2F; 0表示从第0个字符开始，7表示替换长度为7的内容，b表示替换的内容，长度可以不同。a &#x3D; hello world;</code></pre><h2 id="Leader教的转换方法"><a href="#Leader教的转换方法" class="headerlink" title="Leader教的转换方法"></a>Leader教的转换方法</h2><pre class="language-none"><code class="language-none">QByteArray a &#x3D; QSerialPort.readAll();QString tt &#x3D; a.toHex();QByteArray tt2 &#x3D; QByteArray().fromHex(tt.toLatin1());</code></pre><p>这里需要好好学习下各个函数的作用，列出来，不然直接copy拿去用就好。  </p><hr><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>QByteArray常见使用方式：<a href="https://blog.csdn.net/weixin_38931060/article/details/117992884?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_38931060/article/details/117992884?spm=1001.2014.3001.5502</a><br>QT中常见QByteArray，QString，char,10进制，16进制之间转换：<a href="https://blog.csdn.net/weixin_38931060/article/details/117994816?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_38931060/article/details/117994816?spm=1001.2014.3001.5502</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt数据库</title>
      <link href="2023/03/24/Qt%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2023/03/24/Qt%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;最近项目遇到需求，每批芯片有上千颗，需要在一个温度点下完成所有的数据采集后，存入数据库，换芯片，采集，直到一批芯片全部采集完。由于这个数量级，想要将所有数据存在本地内存已经是很不现实很不方便了，所以必须引入数据库，以解决数据量的问题。<br>&emsp;&emsp;所以需要使用SQLite数据库，轻量，好用。而Qt与数据库交互需要用到的便是 QSqlDatabase相关的方法了。<br>&emsp;&emsp;本文章仅记录该次工作所用到的方法和流程。</p><h1 id="方法变量一览"><a href="#方法变量一览" class="headerlink" title="方法变量一览"></a>方法变量一览</h1><pre class="language-none"><code class="language-none">QSqlDatabase db;</code></pre><p>数据库交互的共用变量，管理与数据库的连接，所以需要声明在头文件。</p><pre class="language-none"><code class="language-none">db &#x3D; QSqlDatabase::addDatabase(&quot;QSQLITE&quot;,&quot;connect1&quot;);db.setDatabaseName(QApplication::applicationDirPath()+tr(&quot;&#x2F;test.db&quot;));db.open();</code></pre><p>此处为初始化数据库相关的内容，通过 addDatabase 来进行数据库类型（QSQLITE）和连接名称（connect1）的声明。因为本次内容为SQLITE，故第一个参数填QSQLITE，此外若为MYSQL，可填QMYSQL。第二个参数为非必要参数，用以在多个数据库建立连接时，做名字区分，不然会相互顶替连接。<br>setDatabaseName，在SQLITE中就是设置文件路径，若没有文件则创建文件，MySQL则是命名数据库。<br>open，开启与数据库的连接，任何sql语句都只有连接状态才能正确执行。  </p><pre class="language-none"><code class="language-none">QSqlQuery query(db);bool success &#x3D; query.exec(&quot;CREATE TABLE Mydatas(&quot;                            &quot;id INTEGER PRIMARY KEY AUTOINCREMENT,&quot;                            &quot;dataA INTEGER,&quot;                            &quot;dataB INTEGER,&quot;                            &quot;Result INTEGER)&quot;);QSqlQuery query(db);QString sql &#x3D; QString(&quot;UPDATE Mydatas SET Result &#x3D; %2 WHERE id &#x3D; %1&quot;)                        .arg(a).arg(b);query.prepare(sql);bool result &#x3D; query.exec();query.finish();</code></pre><p>执行SQL语句，可以通过 QString 字符串拼接实现数据绑定，也可通过 bindvalue 实现数据绑定。执行后一定要记得finish掉query，不然可能会影响事务的提交与回滚。</p><pre class="language-none"><code class="language-none">db.transaction();db.commit();db.rollback();</code></pre><p>事务方法很简单，通过 transaction 开启事务，往后所有的 sql 操作都算在事务当中，完成一个事务后通过 commit 提交事务，通过 rollback 回滚事务。这里需要注意每个 sql 操作前可能会有 db.open 检查操作，必须去掉，不然数据库的重新开启会关闭事务，导致 commit rollback 失败。  </p><pre class="language-none"><code class="language-none">if(res1&amp;&amp;res2)&#123;    if(!QSqlDatabase::database().commit())&#123;        QMessageBox::critical(this,&quot;Error&quot;,&quot;操作失败，将要回滚&quot;);        if(!QSqlDatabase::database().rollback())&#123;            QMessageBox::critical(this,&quot;Error&quot;,&quot;回滚失败&quot;);        &#125;    &#125;else&#123;        doShowBackResult();        &#x2F;&#x2F;qDebug()&lt;&lt;&quot;show &quot;;    &#125;    &#125;else&#123;    qDebug()&lt;&lt;query.lastError();    QMessageBox::critical(this,&quot;Error&quot;,&quot;操作失败，将要回滚&quot;);    if(!QSqlDatabase::database().rollback())&#123;        QMessageBox::critical(this,&quot;Error&quot;,&quot;回滚失败&quot;);        qDebug()&lt;&lt;QSqlDatabase::database().lastError();    &#125;&#125;</code></pre><p>上为标准事务写法，带错误信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown学习笔记</title>
      <link href="2021/06/16/markdown%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/06/16/markdown%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown学习"><a href="#markdown学习" class="headerlink" title="markdown学习"></a>markdown学习</h1><h2 id="markdown标题"><a href="#markdown标题" class="headerlink" title="markdown标题"></a>markdown标题</h2><h3 id="1-使用-和-标记一级和二级标题"><a href="#1-使用-和-标记一级和二级标题" class="headerlink" title="1.使用=和-标记一级和二级标题"></a>1.使用=和-标记一级和二级标题</h3><pre class="language-none"><code class="language-none">我展示的是一级标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;我展示的是二级标题--------</code></pre><h3 id="2-使用-号标记"><a href="#2-使用-号标记" class="headerlink" title="2.使用#号标记"></a>2.使用#号标记</h3><p>使用 <kbd>#</kbd> 号可表示 1-6 级标题，一级标题对应一个 <kbd>#</kbd> 号，二级标题对应两个 <kbd>#</kbd> 号，以此类推。</p><h2 id="Markdown段落"><a href="#Markdown段落" class="headerlink" title="Markdown段落"></a>Markdown段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，<strong>段落的换行是使用两个以上空格加上回车。</strong><br><img src="https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg" alt="test"><br>当然也可以在段落后面使用一个空行来表示重新开始一个段落。<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg">  </p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p><pre class="language-none"><code class="language-none">*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em>  </p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：  </p><pre class="language-none"><code class="language-none">**** * ******- - -----------</code></pre><hr><hr><hr><hr><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <kbd>~~</kbd> 即可，实例如下：  </p><pre class="language-none"><code class="language-none">RUNOOB.COMGOOGLE.COM~~BAIDU.COM~~</code></pre><p>RUNOOB.COM<br>GOOGLE.COM<br><del>BAIDU.COM</del>  </p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过 HTML 的 <kbd>&lt;u></kbd> 标签来实现：<br><u>test</u></p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:  </p><pre class="language-none"><code class="language-none">[^要注明的文本]</code></pre><p>以下实例演示了脚注的用法：</p><pre class="language-none"><code class="language-none">创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre><p>演示效果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif">  </p><p>创建脚注格式类似这样 [^RUNOOB]。  </p><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！  </p><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容： </p><pre class="language-none"><code class="language-none">* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项<br>有序列表使用数字并加上 . 号来表示，如：<pre class="language-none"><code class="language-none">1. 第一项2. 第二项3. 第三项</code></pre></li></ul><ol><li>第一项</li><li>第二项</li><li>第三项<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3>列表嵌套只需在子列表中的选项前面添加四个空格即可：<pre class="language-none"><code class="language-none">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre></li><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="Markdown区块"><a href="#Markdown区块" class="headerlink" title="Markdown区块"></a>Markdown区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><pre class="language-none"><code class="language-none">&gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想</code></pre><blockquote><p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：  </p><pre class="language-none"><code class="language-none">&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套  </p></blockquote></blockquote></blockquote><h2 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h2><p>区块中使用列表实例如下：</p><pre class="language-none"><code class="language-none">&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h2 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h2><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p><p>列表中使用区块实例如下：</p><pre class="language-none"><code class="language-none">* 第一项    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想* 第二项</code></pre><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><pre class="language-none"><code class="language-none">&#96;printf()&#96; 函数</code></pre><p><code>printf()</code> 函数</p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab 键）</strong>。</p><p>实例如下：</p><pre class="language-none"><code class="language-none">test()</code></pre><pre><code>test()</code></pre><p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><h2 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h2><p>链接使用方法如下：  </p><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><p>例</p><pre><code>这是[连接](http://www.baidu.com)</code></pre><p>这是<a href="http://www.baidu.com/">连接</a></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre class="language-none"><code class="language-none">这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http:&#x2F;&#x2F;www.google.com&#x2F;  [runoob]: http:&#x2F;&#x2F;www.runoob.com&#x2F;</code></pre><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h2 id="Markdown图片"><a href="#Markdown图片" class="headerlink" title="Markdown图片"></a>Markdown图片</h2><p>Markdown 图片语法格式如下：</p><pre class="language-none"><code class="language-none">![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></pre><ul><li>开头一个感叹号 !  </li><li>接着一个方括号，里面放上图片的替代文字  </li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。<br>使用实例:<pre class="language-none"><code class="language-none">![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png)![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png &quot;RUNOOB&quot;)</code></pre><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></li></ul><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>当然，你也可以像网址那样对图片网址使用变量:  </p><pre class="language-none"><code class="language-none">这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）[1]: http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png</code></pre><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p><pre class="language-none"><code class="language-none">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png&quot; width&#x3D;&quot;50%&quot;&gt;</code></pre><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown 制作表格使用 <kbd>|</kbd> 来分隔不同的单元格，使用<kbd>-</kbd> 来分隔表头和其他行。</p><p>语法格式如下：</p><pre class="language-none"><code class="language-none">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对齐方式<br><strong>我们可以设置表格的对齐方式:</strong></p><ul><li><kbd>-:</kbd> 设置内容和标题栏居右对齐。  </li><li><kbd>:-</kbd> 设置内容和标题栏居左对齐。  </li><li><kbd>:-:</kbd> 设置内容和标题栏居中对齐。  <pre class="language-none"><code class="language-none">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre></li></ul><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="Markdown高级技巧"><a href="#Markdown高级技巧" class="headerlink" title="Markdown高级技巧"></a>Markdown高级技巧</h2><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：</p><pre class="language-none"><code class="language-none">使用 &lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Alt&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Del&lt;&#x2F;kbd&gt; 重启电脑</code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑  </p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre class="language-none"><code class="language-none">**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p><strong>文本加粗</strong><br>** 正常显示星号 **<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre class="language-none"><code class="language-none">\   反斜线&#96;   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h2 id="小实例实现"><a href="#小实例实现" class="headerlink" title="小实例实现"></a>小实例实现</h2><div style="float:left"><a class="fancybox fancybox.image" href="https://i0.hdslb.com/bfs/album/6582ab0f09d86a876f0c7cc1cc072f09771e2d5f.jpg" itemscope="" itemtype="http://schema.org/ImageObject" itemprop="url" data-fancybox="default" rel="default"><img src="https://i0.hdslb.com/bfs/album/6582ab0f09d86a876f0c7cc1cc072f09771e2d5f.jpg" referrerpolicy="no-referrer" width="180px"></a></div><div><div class="table-container"><table width="500px"><tbody><tr><td class="title_main" colspan="2" rowspan="2"><p class="title_cn">佐贺偶像是传奇 第2期</p><p class="title_jp">ゾンビランドサガ リベンジ</p></td><td class="type_a">原创动画</td></tr><tr><td class="type_tag">僵尸/偶像/独特</td></tr><tr><td rowspan="2" class="staff">　　导演：境宗久<br>　　编剧：村越繁<br>动画人设：深川可纯<br>　总作监：崔文英<br>　　　　　桑原干根<br>３Ｄ导演：黑岩爱<br>　　音乐：高梨康治/Funta7<br>音乐制作：avex pictures<br>动画制作：MAPPA</td><td rowspan="2" class="cast">巽幸太郎：宫野真守<br>　　源樱：本渡枫<br>二階堂咲：田野麻美<br>　水野爱：种田梨沙<br>绀野纯子：河濑茉希<br>　　夕雾：衣川里佳<br>星川莉莉：田中美海<br>　山田妙：三石琴乃<br>　警察官：吉野裕行 等</td><td class="link_a"><a href="https://zombielandsaga.com/" target="_blank">动画官网</a><br><a href="https://www.bilibili.com/bangumi/play/ep376377" target="_blank">PV</a><p class="broadcast">4/8周四深夜</p></td></tr><tr><td class="link_b"><a href="https://www.bilibili.com/bangumi/media/md28233251" target="_blank" rel="noopener"><img src="https://i0.hdslb.com/bfs/album/c2c2b4b458991a52260503b0e828831c2b6109f1.jpg" referrerpolicy="no-referrer"><br><font color="red">[独家]</font></a></td></tr></tbody></table></div></div><pre class="language-none"><code class="language-none">&lt;div style&#x3D;&quot;float:left&quot;&gt;&lt;a class&#x3D;&quot;fancybox fancybox.image&quot; href&#x3D;&quot;https:&#x2F;&#x2F;i0.hdslb.com&#x2F;bfs&#x2F;album&#x2F;6582ab0f09d86a876f0c7cc1cc072f09771e2d5f.jpg&quot; itemscope&#x3D;&quot;&quot; itemtype&#x3D;&quot;http:&#x2F;&#x2F;schema.org&#x2F;ImageObject&quot; itemprop&#x3D;&quot;url&quot; data-fancybox&#x3D;&quot;default&quot; rel&#x3D;&quot;default&quot;&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;i0.hdslb.com&#x2F;bfs&#x2F;album&#x2F;6582ab0f09d86a876f0c7cc1cc072f09771e2d5f.jpg&quot; referrerpolicy&#x3D;&quot;no-referrer&quot; width&#x3D;&quot;180px&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;div class&#x3D;&quot;table-container&quot;&gt;&lt;table width&#x3D;&quot;500px&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class&#x3D;&quot;title_main&quot; colspan&#x3D;&quot;2&quot; rowspan&#x3D;&quot;2&quot;&gt;&lt;p class&#x3D;&quot;title_cn&quot;&gt;佐贺偶像是传奇 第2期&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;title_jp&quot;&gt;ゾンビランドサガ リベンジ&lt;&#x2F;p&gt;&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;type_a&quot;&gt;原创动画&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td class&#x3D;&quot;type_tag&quot;&gt;僵尸&#x2F;偶像&#x2F;独特&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td rowspan&#x3D;&quot;2&quot; class&#x3D;&quot;staff&quot;&gt;　　导演：境宗久&lt;br&gt;　　编剧：村越繁&lt;br&gt;动画人设：深川可纯&lt;br&gt;　总作监：崔文英&lt;br&gt;　　　　　桑原干根&lt;br&gt;３Ｄ导演：黑岩爱&lt;br&gt;　　音乐：高梨康治&#x2F;Funta7&lt;br&gt;音乐制作：avex pictures&lt;br&gt;动画制作：MAPPA&lt;&#x2F;td&gt;&lt;td rowspan&#x3D;&quot;2&quot; class&#x3D;&quot;cast&quot;&gt;巽幸太郎：宫野真守&lt;br&gt;　　源樱：本渡枫&lt;br&gt;二階堂咲：田野麻美&lt;br&gt;　水野爱：种田梨沙&lt;br&gt;绀野纯子：河濑茉希&lt;br&gt;　　夕雾：衣川里佳&lt;br&gt;星川莉莉：田中美海&lt;br&gt;　山田妙：三石琴乃&lt;br&gt;　警察官：吉野裕行 等&lt;&#x2F;td&gt;&lt;td class&#x3D;&quot;link_a&quot;&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;zombielandsaga.com&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;动画官网&lt;&#x2F;a&gt;&lt;br&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.bilibili.com&#x2F;bangumi&#x2F;play&#x2F;ep376377&quot; target&#x3D;&quot;_blank&quot;&gt;PV&lt;&#x2F;a&gt;&lt;p class&#x3D;&quot;broadcast&quot;&gt;4&#x2F;8周四深夜&lt;&#x2F;p&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td class&#x3D;&quot;link_b&quot;&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.bilibili.com&#x2F;bangumi&#x2F;media&#x2F;md28233251&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;i0.hdslb.com&#x2F;bfs&#x2F;album&#x2F;c2c2b4b458991a52260503b0e828831c2b6109f1.jpg&quot; referrerpolicy&#x3D;&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;font color&#x3D;&quot;red&quot;&gt;[独家]&lt;&#x2F;font&gt;&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a></p><p><a href="https://yuc.wiki/">长门有C的blog</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>screen使用方法</title>
      <link href="2021/05/15/screen%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/15/screen%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>创建：screen -S ###<br><br></p><span id="more"></span><p>查看有多少会话：screen -ls  </p><p>恢复：screen -r ###  </p><p>如果不能恢复：先screen -d ###  </p><p>再screen -r ###  </p><p>删除 screen -S ### -X quit  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> screen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公主连接打轴器探索</title>
      <link href="2021/04/26/%E5%85%AC%E4%B8%BB%E8%BF%9E%E6%8E%A5%E6%89%93%E8%BD%B4%E5%99%A8/"/>
      <url>2021/04/26/%E5%85%AC%E4%B8%BB%E8%BF%9E%E6%8E%A5%E6%89%93%E8%BD%B4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="已弃坑项目"><a href="#已弃坑项目" class="headerlink" title="已弃坑项目"></a>已弃坑项目</h1><span id="more"></span><p>先随手写一些目前的情况 </p><blockquote><p>获得了执行文件<br>通过LPSpy反编译获得源代码<br>更改其中部分代码来实现本地匹配<br>已经能够在雷电模拟器国服进行使用</p></blockquote><p>目前已解决不运行问题1：可能是颜色不匹配，检查启动判定的两处像素颜色。  </p><pre class="language-c#" data-language="c#"><code class="language-c#">private void tmStatus_Tick(object sender, EventArgs e)&#123;isMenu &#x3D; IsMatch(1232, 31, 255, 255, 255);isNoAccelerate &#x3D; IsMatch(1222, 658, 49, 52, 74);isPause &#x3D; IsMatch(639, 282, 255, 247, 247);Invalidate();&#125;</code></pre><p>目前已解决不运行问题2：mumu模拟器台服，能运行但是不读秒。经过研究把每个秒的颜色判定也更换了，可以读秒了。<br>这里不放源码了，放为了解决问题而写的小python脚本。  </p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    img<span class="token operator">=</span>Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"F:/打轴器/台服截图/"</span><span class="token operator">+</span><span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">".png"</span><span class="token punctuation">)</span>    src_strlist <span class="token operator">=</span> img<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token punctuation">)</span>    data <span class="token operator">=</span> src_strlist<span class="token punctuation">[</span><span class="token number">1114</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span></code></pre><p>将台服的0~9秒的截图放在一个文件夹，重命名为类似  0.png  的形式，以此类推。<br>然后通过循环读取图片信息，输出每个0-9s每个秒数情况下某个坐标的RGB颜色信息。<br>然后将结果复制到打轴器源码中使用。  </p><p>目前未解决的不运行的问题1：Mumu模拟器台服，没有自动点击操控，初步怀疑是mumu模拟器软件的实现与雷电不同的原因。<br>经过测试确实是mumu模拟器添加了防脚本功能导致脚本无法在mumu上进行点击操作。<br>加上本项目实现方式精准性不高，现已弃坑。  </p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.zhihu.com/question/52352499/answer/189887218">关于如何python获取图片像素点信息</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 公主连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译技术的应用-脚本语言</title>
      <link href="2021/04/24/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8-%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"/>
      <url>2021/04/24/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8-%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="脚本语言是什么"><a href="#脚本语言是什么" class="headerlink" title="脚本语言是什么"></a>脚本语言是什么</h1><span id="more"></span><p>脚本语言是为了缩短传统的“编写、编译、链接、运行”过程而创建的计算机编程语言。<br>早期的脚本语言经常被称为批处理语言或作业控制语言。<br>一个脚本通常是解释运行而非编译。<br>脚本语言通常都有简单、易学、易用的特性，目的就是希望能让程序员快速完成程序的编写工作。<br><br><br><em>编程语言分为编译型语言和解释型语言，脚本语言就属于解释型语言。</em></p><br>脚本语言是一种计算机程序语言，因此也能让开发者藉以编写出让电脑听命行事的程序。  以简单的方式快速完成某些复杂的事情通常是创造脚本语言的重要原则，  基于这项原则，使得脚本语言通常比C语言、C++语言或 Java之类的系统编程语言要简单容易，  也让脚本语言另有一些属于脚本语言的特性：  <blockquote><p>语法和结构通常比较简单<br>学习和使用通常比较简单<br>通常以容易修改程序的“解释”作为运行方式，而不需要“编译”<br>程序的开发产能优于运行性能</p></blockquote><p>计算机语言是为了各种目的和任务而开发的，<br>一个常见任务就是把各种不同的已有组件连接起来以完成相关任务。<br>大多脚本语言共性是：  </p><blockquote><p>良好的快速开发，<br>有效率的执行，<br>解释而非编译执行，<br>和其它语言编写的程序组件之间通信功能很强大。</p></blockquote><p>许多脚本语言用来执行一次性任务，尤其是系统管理方面。<br>它可以把服务组件粘合起来，因此被广泛用于GUI创建或者命令行，<br>操作系统通常提供一些默认的脚本语言，即通常所谓shell脚本语言。<br><br><br>脚本通常以文本（如ASCII）保存，只在被调用时进行解释或编译。<br>测试大型项目中经常把脚本和其它低级编程语言一起使用，各自发挥优势解决特定问题。<br>脚本经常用于设计互动通信，它有许多可以单独执行的命令，<br>可以做很高级的操作，（如在传统的Unix shell（sh）中，大多操作就是程序本身。）<br><br><br>这些高级命令简化了代码编写过程。诸如内存自动管理和溢出检查等性能问题可以不用考虑。<br>在更低级或非脚本语言中，内存及变量管理和数据结构等耗费人工，为解决一个给定问题需要大量代码，<br>当然这样能够获得更为细致的控制和优化。脚本缺少优化程序以提速或者降低内存的伸缩性。<br><br><br>综上所述，脚本编程速度更快，且脚本文件明显小于如同类C程序文件。<br>这种灵活性是以执行效率为代价的。<br>脚本通常是解释执行的，速度可能很慢，且运行时更耗内存。<br>在很多案例中，如编写一些数十行的小脚本，<br>它所带来的编写优势就远远超过了运行时的劣势，尤其是在当前程序员工资趋高和硬件成本趋低时。<br><br>  </p><p>linux默认的命令行Bash用的指令就是脚本语言的一种。<br>我们常用的Python由于其特性也分类为脚本语言的一种。<br>本人有幸接触过Lua语言，lua也是轻量小巧的脚本语言。<del>应该会有lua相关的博文</del></p><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>既然脚本语言是解释型语言，就必须来讨论一下解释器。就定义上虽然划分了编译型语言和解释型语言，有着各自独有的编译器和解释器，但它们未必就是相互独立的。</p><p>解释器执行程序的方法有：</p><blockquote><p>1.直接执行高级编程言（如Shell内建的编译器）<br>2.转换高级编程语言到更有效率的字节码（Bytecode），并执行字节码<br>3.用解释器包含的编译器对高级语言进行编译，并指示中央处理器执行编译后的程序（例如：JIT）</p></blockquote><p>其中3的——<em>用解释器包含的编译器对高级语言进行编译，并指示中央处理器执行编译后的程序</em>——这句话我觉得很有意思，所以解释器中包含编译器，所谓的读取一句执行一句其实源代码输入后结果的差别，如果出来的是另一种代码，可执行文件，那就是编译器，直接输出源码执行后的结果，那就是解释器。<br>不能因为名字定义就错误认为编译器一定没有编译的过程。<br>比如说可以写一个C语言的解释器，效果是对C语言进行编译，然后运行生成的可执行文件，再将得到的结果直接输出，那么这就是一个定义上的解释器。</p><p>Perl，Python，MATLAB，与Ruby是属于第二种方法，而UCSD Pascal则是属于第三种方式。<br>在翻译的过程中，这组高级语言所写成的程序仍然维持在源代码的格式（或某种中继语言的格式），而程序本身所指涉的动作或行为则由解释器来表现。</p><p>在解释器上运行程序比直接运行编译过的代码来得慢，是因为解释器每次都必须去分析并翻译它所运行到的程序行，而编译过的程序就只是直接运行。<br>这个在运行时的分析被称为”解释式的成本”。<br>在解释器中，变量的访问也是比较慢的，因为每次要访问变量的时候它都必须找出该变量实际存储的位置，而不像编译过的程序在编译的时候就决定好了变量的位置了。</p><h1 id="哪些是编译原理相关的技术"><a href="#哪些是编译原理相关的技术" class="headerlink" title="哪些是编译原理相关的技术"></a>哪些是编译原理相关的技术</h1><p>那么脚本语言中究竟涉及到了哪些编译相关的技术呢？<br>可以确定的是，通过上文的描述，我们可以理解，解释型语言和编译型语言差别在输出对象上，<br>实际执行中，都逃不开词法分析器、语法分析器和语义分析。<br>由于编译型语言和解释型语言的代码执行顺序不同，所以当源码中有错误时，<br>编译型语言会直接在编译过程报错，并不会生成目标代码程序，<br>而解释型语言则会将错误之前的代码段全部执行完毕，然后到有问题的语句再报错。<br>比如：  </p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> hello<span class="token keyword">for</span><span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span><span class="token builtin class-name">echo</span> hello<span class="token keyword">for</span><span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span><span class="token builtin class-name">echo</span> hello<span class="token keyword">done</span><span class="token keyword">done</span></code></pre><p>其中第二个for循环少了do，所以程序会输出一次hello，然后报错。<br>每种解释型语言处理方式不同，但是可以猜测，<br>解释型语言不会逐个“物理行”解析，但是“按命令”解析执行是可以的，<br>比如python在交互模式下就是你输入一行，编译并执行这一行，<br>但是你如果输入是if、while的话，它会让你将代码块都输入完整后才将这一段作为一个完整的命令  </p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言wiki</a><br><a href="https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%99%A8/10418965">解释器百度百科</a><br><a href="https://www.zhihu.com/question/19608553">知乎：Java 是编译型语言还是解释型语言？</a>中的<a href="https://www.zhihu.com/people/rednaxelafx">RednaxelaFX</a>的已失效博文，但是被路人备份了<a href="https://www.cnblogs.com/bozhang/articles/3115089.html">传送门</a><br><a href="https://www.zhihu.com/question/325210206/answer/691007867">知乎：python需要编译，为什么还把他叫做脚本语言？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
            <tag> 脚本语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO blog搭建问题汇总</title>
      <link href="2021/04/22/blog%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2021/04/22/blog%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h1><p>网上下载NodeJS安装包，对应自己的系统，本教程以linux为准。<br>下载后丢到自己想安装的文件夹解压。<br><br></p><span id="more"></span><p>安装完成后通过ln -s 命令将刚刚安装位置的nodejs转为全局命令<br>格式如下：  </p><pre class="language-linux" data-language="linux"><code class="language-linux">ln -s &#x2F;(你安装的位置)&#x2F;nodejs&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin&#x2F; ln -s &#x2F;(你安装的位置)&#x2F;nodejs&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F; </code></pre><p>然后通过npm -v  和 node -v 来验证是否转为全局。  </p><p>或者可以通过修改/root/.bash_profile 的PATH参数，</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:<span class="token operator">&lt;</span><span class="token environment constant">PATH</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span>:<span class="token operator">&lt;</span><span class="token environment constant">PATH</span> <span class="token operator"><span class="token file-descriptor important">2</span>></span>:---:/usr/local/src/nodejs/bin</code></pre><p>将/(你安装的位置)/nodejs/bin添加到路径中，可以一劳永逸  </p><p>成功后进行下一步<br><br>  </p><h1 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h1><p>通过淘宝源进行安装  </p><pre class="language-linux" data-language="linux"><code class="language-linux">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</code></pre><p>如果之前是软连接，这里同样需要ln -s 进行转换全局cnpm，才能使用cnpm  </p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><pre class="language-none"><code class="language-none">cnpm install -g hexo-cli</code></pre><p>通过mkdir在自己想建blog的地方建一个blog文件夹<br>然后转移到blog文件夹下，使用</p><pre class="language-none"><code class="language-none">hexo init</code></pre><p>初始化生成博客环境。再通过</p><pre class="language-none"><code class="language-none">hexo s</code></pre><p>启动博客，开启linux系统的4000端口。</p><pre class="language-bash" data-language="bash"><code class="language-bash">firewall-cmd --add-port<span class="token operator">=</span><span class="token number">123</span>/tcp --permanentfirewall-cmd --reload</code></pre><p>如果是云服务器可以直接通过后台操作开启。<br>然后进入  服务器ip地址:4000  就能看到初始化完成的个人博客界面了</p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 教程 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yobot部署攻略</title>
      <link href="2021/04/21/yobot%E9%83%A8%E7%BD%B2%E6%94%BB%E7%95%A5/"/>
      <url>2021/04/21/yobot%E9%83%A8%E7%BD%B2%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="关于在云服务器上通过centos7部署go-cqhttp-和-yobot"><a href="#关于在云服务器上通过centos7部署go-cqhttp-和-yobot" class="headerlink" title="关于在云服务器上通过centos7部署go-cqhttp 和 yobot"></a>关于在云服务器上通过centos7部署go-cqhttp 和 yobot</h2><span id="more"></span><p>前言：<br>yobot官方使用教程与安装教程<a href="https://yobot.win/install/mirai/">点击这里</a></p><p>博主自己在云服务器上搭建时遇到部分问题，解决后总结在本博文，希望对有需要的人起到帮助。<br>博主云服务器：腾讯云 centos7.6  阿里云 centos 8.3<br>记得要将服务器开启9222端口<br><br></p><h1 id="yobot部分"><a href="#yobot部分" class="headerlink" title="yobot部分"></a>yobot部分</h1><p>安装依赖</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> -y gcc python3 <span class="token function">screen</span> <span class="token function">wget</span></code></pre><p>如果提示 unable to find a match : screen 就通过</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm</code></pre><p>配置yum源<br>请使用 python3 -V 命令确认 python 版本，yobot 支持的 python 版本为 3.6 ~ 3.8</p><p>使用终端复用器<br>这里我们用 screen 作为终端复用工具，<a href="http://h300579.vicp.hk/2021/05/15/screen%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">详细用法</a><br><br><br>官方这里没有细说，大概用法就是 screen -s 新建一个窗口，每次用完窗口通过<kbd>Ctrl</kbd>+<kbd>A</kbd> <kbd>Ctrl</kbd>+<kbd>d</kbd>来使当前窗口detach，然后screen -ls来看已经detach的窗口，通过screen -r 名字或者id来恢复到目标窗口。由于yobot部署需要yobot+go-cqhttp两个软件，所以建议开启两个窗口，分别命名qqbot和miraiqq（可自行命名）<br><br><br>现在新建一个 screen 终端</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">screen</span> -S qqbot</code></pre><p>部署yobot</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/qqbot/yobot<span class="token builtin class-name">cd</span> ~/qqbot/yobot<span class="token comment"># 下载源码，使用 stable 稳定版分支</span><span class="token function">git</span> clone https://github.com/pcrbot/yobot.git -b stable</code></pre><p>注意这里git指令多半会报错没有git  通过</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token function">git</span></code></pre><p>来安装git使git可用  </p><p>然后 git clone 在国内现在速度非常慢不够看，所以建议直接使用国内镜像，代码如下</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com.cnpmjs.org/pcrbot/yobot.git</code></pre><p>clone完成后继续</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> yobot/src/client/<span class="token comment"># 安装依赖</span>pip3 <span class="token function">install</span> -r requirements.txt --user<span class="token comment"># 国内可加上参数 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><span class="token comment"># 生成 yobotg</span>python3 main.py<span class="token comment"># 启用 yobot</span><span class="token function">sh</span> yobotg.sh</code></pre><p>这里会提示 </p><pre class="language-bash" data-language="bash"><code class="language-bash">Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"main.py"</span>, line <span class="token number">36</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from aiocqhttp <span class="token function">import</span> CQHttpModuleNotFoundError: No module named <span class="token string">'aiocqhttp'</span></code></pre><p>我们通过pip3进行aiocqhttp的安装</p><pre class="language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> aiocqhttp<span class="token punctuation">[</span>all<span class="token punctuation">]</span></code></pre><p>这里可能会提示我们缺少python.h<br>我们通过下方命令安装python-devel</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> python3-devel</code></pre><p>如果提示与已存在的python-devel冲突，通过 yum remove 名字  来卸载已安装的python-devel后再进行安装  </p><p>安装完devel后再次安装aiocqhttp，成功安装后再次运行安装依赖，应该就能顺利执行完毕。<br>代码如下:</p><pre class="language-bash" data-language="bash"><code class="language-bash">pip3 <span class="token function">install</span> aiocqhttp<span class="token punctuation">[</span>all<span class="token punctuation">]</span>pip3 <span class="token function">install</span> -r requirements.txt --user</code></pre><br>安装完依赖不出错的话再次启动yobot  <pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 启用 yobot</span><span class="token function">sh</span> yobotg.sh</code></pre><p>出现这个界面就表明yobot已经成功安装了。</p><pre class="language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;              _           _             | |         | |  _   _  ___ | |__   ___ | |_ | | | |&#x2F; _ \| &#39;_ \ &#x2F; _ \| __| | |_| | (_) | |_) | (_) | |_  \__, |\___&#x2F;|_.__&#x2F; \___&#x2F; \__|   __&#x2F; |  |___&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在初始化...设置已初始化，发送help获取帮助yobot[v3.6.11]源码版初始化完成，启动服务...Running on https:&#x2F;&#x2F;0.0.0.0:9222 (CTRL + C to quit)[2021-04-21 09:55:52,474] ASGI Framework Lifespan error, continuing without Lifespan support刷新日服日程表成功刷新台服日程表成功刷新国服日程表成功</code></pre><p>完成后就可以<kbd>Ctrl</kbd>+<kbd>A</kbd> <kbd>Ctrl</kbd>+<kbd>d</kbd>把yobot挂到后台运行了。</p><h1 id="go-cqhttp部分"><a href="#go-cqhttp部分" class="headerlink" title="go-cqhttp部分"></a>go-cqhttp部分</h1><p>通过screen新建一个窗口</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">screen</span> -S miraiqq</code></pre><p>然后</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/qqbot/mirai<span class="token builtin class-name">cd</span> ~/qqbot/mirai</code></pre><p>由于国内众所周知的原因，在国内连接不上github，下载速度很感人，所以这里我们直接将文件通过sftp上传到服务器  /root/qqbot/miraiqq/ 下。<br>文件是博主从github上直接下的最新版<br><a href="https://pan.baidu.com/s/1jQQsVmIjhxgLrs5CqBUpaA">下载连接</a><br>提取码：20w1<br>上传完毕后继续操作</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> zxvf go-cqhttp_linux_amd64.tar.gz<span class="token function">rm</span> go-cqhttp_linux_amd64.tar.gz</code></pre><p>修改go-cqhttp配置文件</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/qqbot/mirai<span class="token comment"># 先执行</span>./go-cqhttp<span class="token comment"># 此时会生成一个 config.yml 文件</span><span class="token comment"># 修改这个文件</span></code></pre><p>这里可以直接下载我调好的config.yml模板，在里面修改qq账号密码然后就可以启动登录了<br><a href="https://pan.baidu.com/s/1p5roH3w2NJkr0kii_e_8Fw">下载链接</a><br>提取码：94ai<br>下载后修改config.yml中的qq账号和qq密码两栏<br>将其上传至/root/qqbot/mirai/覆盖已存在的config.yml<br>启动go-cqhttp  </p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/qqbot/mirai<span class="token function">chmod</span> +x go-cqhttp./go-cqhttp</code></pre><p>部署完成，<kbd>Ctrl</kbd>+<kbd>A</kbd> <kbd>Ctrl</kbd>+<kbd>d</kbd>将mirai也挂起到后台  </p><h1 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h1><p>向mirai登录的qq号发送version，回复当前版本号说明配置成功</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> yobot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
